{"version":3,"sources":["webpack:///webpack/bootstrap fe1a8668422c5f491944","webpack:///./source/scripts/responsive-lazyload.browser.js","webpack:///./source/scripts/responsive-lazyload.js"],"names":[],"mappings":"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","file":"responsive-lazyload.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fe1a8668422c5f491944\n **/","import {lazyLoadImages} from './responsive-lazyload';\n\n// Create a global for access without using webpack.\nwindow.responsiveLazyload = {lazyLoadImages};\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/scripts/responsive-lazyload.browser.js\n **/","/**\n * Check if an element is visible at all in the viewport.\n * @param  {Element} el the element to check\n * @return {Boolean}    `true` if the element is visible at all; `false` if not\n */\nfunction isElementVisible(el) {\n  const position = el.getBoundingClientRect();\n  const wHeight = window.innerHeight || document.documentElement.clientHeight;\n\n  return (\n    (position.top >= 0 && position.top <= wHeight) ||\n    (position.bottom >= 0 && position.bottom <= wHeight)\n  );\n}\n\n/**\n * Prevents a function from firing too often.\n * @param  {Function} func  the function to throttle\n * @param  {Number}   limit the amount of milliseconds to wait between calls\n * @return {Function}       function to check if the function should be called\n */\nfunction throttle(func, limit = 200) {\n  let wait = false;\n\n  return () => {\n    if (!wait) {\n      func.call();\n      wait = true;\n      setTimeout(() => { wait = false; }, limit);\n    }\n  };\n}\n\n/**\n * Check if an image is visible and trigger an event if so.\n * @param  {Element} image the image to check\n * @param  {Event}   event an event to dispatch if the image is in the viewport\n * @return {Boolean}       true if the image is in the viewport; false if not\n */\nconst maybeTriggerImageLoad = (image, event) => {\n  if (!image.dataset.loaded && isElementVisible(image)) {\n    image.dispatchEvent(event);\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Finds the image to be lazyloaded.\n * @param  {Element} container `img` element to be lazyloaded or its container\n * @return {Element}           the `img` element to be lazyloaded\n */\nconst findImageElement = container => {\n  if (container.tagName.toLowerCase() === 'img') {\n    return container;\n  } else {\n    return container.querySelector('img');\n  }\n};\n\n/**\n * This almost seems too easy, but we simply swap in the correct srcset.\n * @param  {Event} event the triggered event\n * @return {Void}\n */\nconst loadImage = event => {\n  event.target.srcset = event.target.dataset.lazyload;\n\n  // Add a `data-loaded` attribute to prevent duplicate loads.\n  event.target.dataset.loaded = true;\n};\n\n/**\n * Remove the loading class from the container element.\n * @param  {Element} image        the image being loaded\n * @param  {String}  loadingClass the class to remove\n * @return {Void}\n */\nconst removeLoadingClass = (image, loadingClass) => {\n  image.parentNode.classList.remove(loadingClass);\n};\n\nconst hasSrcsetSupport = () => {\n  return 'srcset' in document.createElement('img');\n};\n\n/**\n * Initializes the lazyloader and adds all relevant handlers.\n * @param  {String} options.containerClass the container for images to lazyload\n * @param  {String} options.loadingClass   the loading class for lazyloading\n * @return {Void}\n */\nexport function lazyLoadImages({\n  containerClass = \"js--lazyload\",\n  loadingClass = \"js--lazyload--loading\",\n  callback = () => {},\n} = {}) {\n\n  // Before we do anything, check if the browser supports `srcset`\n  if (!hasSrcsetSupport()) {\n\n    // If not, remove the loading class and bail out.\n    removeLoadingClass(loadingClass);\n  }\n\n  // If we get here, `srcset` is supported and we can start processing things.\n  const toLoad = document.getElementsByClassName(containerClass);\n  const images = [].map.call(toLoad, findImageElement);\n\n  // Create a custom event to trigger the event load.\n  const lazyLoadEvent = new Event('lazyload-init');\n\n  // Attach an onload handler to each image.\n  images.forEach(image => {\n\n    /*\n     * Once the image is loaded, we want to remove the loading class so any\n     * loading animations or other effects can be disabled.\n     */\n    image.addEventListener('load', event => {\n      removeLoadingClass(event.target, loadingClass);\n      callback(event);\n    });\n\n    /*\n     * Set up a listener for the custom event that triggers the image load\n     * handler (which loads the image).\n     */\n    image.addEventListener('lazyload-init', loadImage);\n\n    /*\n     * Check if the image is already in the viewport. If so, load it.\n     */\n    maybeTriggerImageLoad(image, lazyLoadEvent);\n  });\n\n  /*\n   * Add an event listener when the page is scrolled. To avoid bogging down the\n   * page, we throttle this call to only run every 100ms.\n   */\n  const scrollHandler = throttle(() => {\n    images.forEach(image => {\n      maybeTriggerImageLoad(image, lazyLoadEvent);\n    });\n  }, 100);\n  window.addEventListener('scroll', scrollHandler);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/scripts/responsive-lazyload.js\n **/"],"sourceRoot":""}