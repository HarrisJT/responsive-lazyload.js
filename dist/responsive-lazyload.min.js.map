{"version":3,"sources":["webpack:///responsive-lazyload.min.js","webpack:///webpack/bootstrap 9ef9905c9785fdd35517","webpack:///./source/scripts/responsive-lazyload.browser.js","webpack:///./source/scripts/responsive-lazyload.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_responsiveLazyload","window","responsiveLazyload","lazyLoadImages","isElementVisible","el","position","getBoundingClientRect","wHeight","innerHeight","document","documentElement","clientHeight","top","bottom","throttle","func","limit","arguments","length","undefined","wait","setTimeout","config","createElement","initialize","Object","defineProperty","value","maybeTriggerImageLoad","image","event","dataset","dispatchEvent","findImageElement","container","tagName","toLowerCase","querySelector","loadImage","target","srcset","lazyload","removeLoadingClass","loadingClass","element","classList","contains","remove","parentNode","_ref","_ref$containerClass","containerClass","_ref$loadingClass","_ref$callback","callback","containers","getElementsByClassName","i","l","add","images","map","lazyLoadEvent","Event","forEach","addEventListener","scrollHandler"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/BI,EAAOD,QAAUH,EAAoB,IAKhC,SAASI,EAAQD,EAASH,GAE/B,YErDD,IAAAW,GAAAX,EAAA,EAGAY,QAAOC,oBAAsBC,eAAAH,EAAAG,iBF2DvB,SAASV,EAAQD,GAEtB,YG3DD,SAASY,GAAiBC,GACxB,GAAMC,GAAWD,EAAGE,wBACdC,EAAUP,OAAOQ,aAAeC,SAASC,gBAAgBC,YAE/D,OACGN,GAASO,KAAO,GAAKP,EAASO,KAAOL,GACrCF,EAASQ,QAAU,GAAKR,EAASQ,QAAUN,EAUhD,QAASO,GAASC,GAAmB,GAAbC,GAAaC,UAAAC,QAAA,GAAAC,SAAAF,UAAA,GAAL,IAAKA,UAAA,GAC/BG,GAAO,CAEX,OAAO,YACAA,IACHL,EAAKpB,OACLyB,GAAO,EACPC,WAAW,WAAQD,GAAO,GAAUJ,KAuInC,QAASd,KAA4B,GAAboB,GAAaL,UAAAC,QAAA,GAAAC,SAAAF,UAAA,MAAAA,UAAA,EAG1C,OAAI,UAAYR,UAASc,cAAc,SAGrCC,EAAWF,IAEJ,GHzGVG,OAAOC,eAAenC,EAAS,cAC7BoC,OAAO,IAETpC,EG8FeW,gBA5HhB,IAAM0B,GAAwB,SAACC,EAAOC,GACpC,QAAKD,EAAME,QAAQrC,SAAUS,EAAiB0B,MAC5CA,EAAMG,cAAcF,IAEb,IAWLG,EAAmB,SAAAC,GACvB,MAAwC,QAApCA,EAAUC,QAAQC,cACbF,EAEAA,EAAUG,cAAc,QAS7BC,EAAY,SAAAR,GAChBA,EAAMS,OAAOC,OAASV,EAAMS,OAAOR,QAAQU,SAG3CX,EAAMS,OAAOR,QAAQrC,QAAS,GAS1BgD,EAAqB,SAACb,EAAOc,GAQjC,IAPA,GAAIC,GAAUf,EAO2B,SAAlCe,EAAQT,QAAQC,eACjBQ,EAAQC,UAAUC,SAASH,GAC7BC,EAAQC,UAAUE,OAAOJ,GAEzBC,EAAUA,EAAQI,YAYlBxB,EAAa,WAQjB,IAAK,GAJIyB,GAAAhC,UAAAC,QAAA,GAAAC,SAAAF,UAAA,MAAAA,UAAA,GAAAiC,EAAAD,EAHTE,iBAGShC,SAAA+B,EAHQ,eAGRA,EAAAE,EAAAH,EAFTN,eAESxB,SAAAiC,EAFM,wBAENA,EAAAC,EAAAJ,EADTK,WACSnC,SAAAkC,EADE,aACFA,EAGHE,EAAa9C,SAAS+C,uBAAuBL,GAC1CM,EAAI,EAAGC,EAAIH,EAAWrC,OAAQuC,EAAIC,EAAGD,IAC5CF,EAAWE,GAAGZ,UAAUc,IAAIhB,EAI9B,IAAMiB,MAAYC,IAAIlE,KAAK4D,EAAYtB,GAGjC6B,EAAgB,GAAIC,OAAM,gBAGhCH,GAAOI,QAAQ,SAAAnC,GAMbA,EAAMoC,iBAAiB,OAAQ,SAAAnC,GAC7BY,EAAmBZ,EAAMS,OAAQI,GACjCW,EAASxB,KAOXD,EAAMoC,iBAAiB,gBAAiB3B,GAKxCV,EAAsBC,EAAOiC,IAO/B,IAAMI,GAAgBpD,EAAS,WAC7B8C,EAAOI,QAAQ,SAAAnC,GACbD,EAAsBC,EAAOiC,MAE9B,IACH9D,QAAOiE,iBAAiB,SAAUC","file":"responsive-lazyload.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _responsiveLazyload = __webpack_require__(2);\n\t\n\t// Create a global for access without using webpack.\n\twindow.responsiveLazyload = { lazyLoadImages: _responsiveLazyload.lazyLoadImages };\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.lazyLoadImages = lazyLoadImages;\n\t/**\n\t * Check if an element is visible at all in the viewport.\n\t * @param  {Element} el the element to check\n\t * @return {Boolean}    `true` if the element is visible at all; `false` if not\n\t */\n\tfunction isElementVisible(el) {\n\t  var position = el.getBoundingClientRect();\n\t  var wHeight = window.innerHeight || document.documentElement.clientHeight;\n\t\n\t  return position.top >= 0 && position.top <= wHeight || position.bottom >= 0 && position.bottom <= wHeight;\n\t}\n\t\n\t/**\n\t * Prevents a function from firing too often.\n\t * @param  {Function} func  the function to throttle\n\t * @param  {Number}   limit the amount of milliseconds to wait between calls\n\t * @return {Function}       function to check if the function should be called\n\t */\n\tfunction throttle(func) {\n\t  var limit = arguments.length <= 1 || arguments[1] === undefined ? 200 : arguments[1];\n\t\n\t  var wait = false;\n\t\n\t  return function () {\n\t    if (!wait) {\n\t      func.call();\n\t      wait = true;\n\t      setTimeout(function () {\n\t        wait = false;\n\t      }, limit);\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Check if an image is visible and trigger an event if so.\n\t * @param  {Element} image the image to check\n\t * @param  {Event}   event an event to dispatch if the image is in the viewport\n\t * @return {Boolean}       true if the image is in the viewport; false if not\n\t */\n\tvar maybeTriggerImageLoad = function maybeTriggerImageLoad(image, event) {\n\t  if (!image.dataset.loaded && isElementVisible(image)) {\n\t    image.dispatchEvent(event);\n\t\n\t    return true;\n\t  }\n\t\n\t  return false;\n\t};\n\t\n\t/**\n\t * Finds the image to be lazyloaded.\n\t * @param  {Element} container `img` element to be lazyloaded or its container\n\t * @return {Element}           the `img` element to be lazyloaded\n\t */\n\tvar findImageElement = function findImageElement(container) {\n\t  if (container.tagName.toLowerCase() === 'img') {\n\t    return container;\n\t  } else {\n\t    return container.querySelector('img');\n\t  }\n\t};\n\t\n\t/**\n\t * This almost seems too easy, but we simply swap in the correct srcset.\n\t * @param  {Event} event the triggered event\n\t * @return {Void}\n\t */\n\tvar loadImage = function loadImage(event) {\n\t  event.target.srcset = event.target.dataset.lazyload;\n\t\n\t  // Add a `data-loaded` attribute to prevent duplicate loads.\n\t  event.target.dataset.loaded = true;\n\t};\n\t\n\t/**\n\t * Remove the loading class from the lazyload wrapper.\n\t * @param  {Element} image        the image being loaded\n\t * @param  {String}  loadingClass the class to remove\n\t * @return {Void}\n\t */\n\tvar removeLoadingClass = function removeLoadingClass(image, loadingClass) {\n\t  var element = image;\n\t\n\t  /*\n\t   * Since there may be additional elements wrapping the image (e.g. a link),\n\t   * we run a loop to check the imageâ€™s ancestors until we either find the\n\t   * element with the loading class or hit the `body` element.\n\t   */\n\t  while (element.tagName.toLowerCase() !== 'body') {\n\t    if (element.classList.contains(loadingClass)) {\n\t      element.classList.remove(loadingClass);\n\t    } else {\n\t      element = element.parentNode;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Initializes the lazyloader and adds the relevant classes and handlers.\n\t * @param  {String}   options.containerClass the lazyloaded image wrapper\n\t * @param  {String}   options.loadingClass   the class that signifies loading\n\t * @param  {Function} options.callback       a function to fire on image load\n\t * @return {Void}\n\t */\n\tvar initialize = function initialize() {\n\t  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t  var _ref$containerClass = _ref.containerClass;\n\t  var containerClass = _ref$containerClass === undefined ? \"js--lazyload\" : _ref$containerClass;\n\t  var _ref$loadingClass = _ref.loadingClass;\n\t  var loadingClass = _ref$loadingClass === undefined ? \"js--lazyload--loading\" : _ref$loadingClass;\n\t  var _ref$callback = _ref.callback;\n\t  var callback = _ref$callback === undefined ? function () {} : _ref$callback;\n\t\n\t\n\t  // Find all the containers and add the loading class.\n\t  var containers = document.getElementsByClassName(containerClass);\n\t  for (var i = 0, l = containers.length; i < l; i++) {\n\t    containers[i].classList.add(loadingClass);\n\t  }\n\t\n\t  // If we get here, `srcset` is supported and we can start processing things.\n\t  var images = [].map.call(containers, findImageElement);\n\t\n\t  // Create a custom event to trigger the event load.\n\t  var lazyLoadEvent = new Event('lazyload-init');\n\t\n\t  // Attach an onload handler to each image.\n\t  images.forEach(function (image) {\n\t\n\t    /*\n\t     * Once the image is loaded, we want to remove the loading class so any\n\t     * loading animations or other effects can be disabled.\n\t     */\n\t    image.addEventListener('load', function (event) {\n\t      removeLoadingClass(event.target, loadingClass);\n\t      callback(event);\n\t    });\n\t\n\t    /*\n\t     * Set up a listener for the custom event that triggers the image load\n\t     * handler (which loads the image).\n\t     */\n\t    image.addEventListener('lazyload-init', loadImage);\n\t\n\t    /*\n\t     * Check if the image is already in the viewport. If so, load it.\n\t     */\n\t    maybeTriggerImageLoad(image, lazyLoadEvent);\n\t  });\n\t\n\t  /*\n\t   * Add an event listener when the page is scrolled. To avoid bogging down the\n\t   * page, we throttle this call to only run every 100ms.\n\t   */\n\t  var scrollHandler = throttle(function () {\n\t    images.forEach(function (image) {\n\t      maybeTriggerImageLoad(image, lazyLoadEvent);\n\t    });\n\t  }, 100);\n\t  window.addEventListener('scroll', scrollHandler);\n\t};\n\t\n\t/**\n\t * The public function to initialize lazyloading\n\t * @param  {Object} config configuration options (see `initialize()`)\n\t * @return {Boolean}       `true` if initialized; `false` if not\n\t */\n\tfunction lazyLoadImages() {\n\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\n\t  // Before we do anything, check if the browser supports `srcset`\n\t  if ('srcset' in document.createElement('img')) {\n\t\n\t    // If we have `srcset` support, initialize the lazyloader.\n\t    initialize(config);\n\t\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** responsive-lazyload.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9ef9905c9785fdd35517\n **/","import {lazyLoadImages} from './responsive-lazyload';\n\n// Create a global for access without using webpack.\nwindow.responsiveLazyload = {lazyLoadImages};\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/scripts/responsive-lazyload.browser.js\n **/","/**\n * Check if an element is visible at all in the viewport.\n * @param  {Element} el the element to check\n * @return {Boolean}    `true` if the element is visible at all; `false` if not\n */\nfunction isElementVisible(el) {\n  const position = el.getBoundingClientRect();\n  const wHeight = window.innerHeight || document.documentElement.clientHeight;\n\n  return (\n    (position.top >= 0 && position.top <= wHeight) ||\n    (position.bottom >= 0 && position.bottom <= wHeight)\n  );\n}\n\n/**\n * Prevents a function from firing too often.\n * @param  {Function} func  the function to throttle\n * @param  {Number}   limit the amount of milliseconds to wait between calls\n * @return {Function}       function to check if the function should be called\n */\nfunction throttle(func, limit = 200) {\n  let wait = false;\n\n  return () => {\n    if (!wait) {\n      func.call();\n      wait = true;\n      setTimeout(() => { wait = false; }, limit);\n    }\n  };\n}\n\n/**\n * Check if an image is visible and trigger an event if so.\n * @param  {Element} image the image to check\n * @param  {Event}   event an event to dispatch if the image is in the viewport\n * @return {Boolean}       true if the image is in the viewport; false if not\n */\nconst maybeTriggerImageLoad = (image, event) => {\n  if (!image.dataset.loaded && isElementVisible(image)) {\n    image.dispatchEvent(event);\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Finds the image to be lazyloaded.\n * @param  {Element} container `img` element to be lazyloaded or its container\n * @return {Element}           the `img` element to be lazyloaded\n */\nconst findImageElement = container => {\n  if (container.tagName.toLowerCase() === 'img') {\n    return container;\n  } else {\n    return container.querySelector('img');\n  }\n};\n\n/**\n * This almost seems too easy, but we simply swap in the correct srcset.\n * @param  {Event} event the triggered event\n * @return {Void}\n */\nconst loadImage = event => {\n  event.target.srcset = event.target.dataset.lazyload;\n\n  // Add a `data-loaded` attribute to prevent duplicate loads.\n  event.target.dataset.loaded = true;\n};\n\n/**\n * Remove the loading class from the lazyload wrapper.\n * @param  {Element} image        the image being loaded\n * @param  {String}  loadingClass the class to remove\n * @return {Void}\n */\nconst removeLoadingClass = (image, loadingClass) => {\n  let element = image;\n\n  /*\n   * Since there may be additional elements wrapping the image (e.g. a link),\n   * we run a loop to check the imageâ€™s ancestors until we either find the\n   * element with the loading class or hit the `body` element.\n   */\n  while (element.tagName.toLowerCase() !== 'body') {\n    if (element.classList.contains(loadingClass)) {\n      element.classList.remove(loadingClass);\n    } else {\n      element = element.parentNode;\n    }\n  }\n};\n\n/**\n * Initializes the lazyloader and adds the relevant classes and handlers.\n * @param  {String}   options.containerClass the lazyloaded image wrapper\n * @param  {String}   options.loadingClass   the class that signifies loading\n * @param  {Function} options.callback       a function to fire on image load\n * @return {Void}\n */\nconst initialize = ({\n  containerClass = \"js--lazyload\",\n  loadingClass = \"js--lazyload--loading\",\n  callback = () => {},\n} = {}) => {\n\n  // Find all the containers and add the loading class.\n  const containers = document.getElementsByClassName(containerClass);\n  for (let i = 0, l = containers.length; i < l; i++) {\n    containers[i].classList.add(loadingClass);\n  }\n\n  // If we get here, `srcset` is supported and we can start processing things.\n  const images = [].map.call(containers, findImageElement);\n\n  // Create a custom event to trigger the event load.\n  const lazyLoadEvent = new Event('lazyload-init');\n\n  // Attach an onload handler to each image.\n  images.forEach(image => {\n\n    /*\n     * Once the image is loaded, we want to remove the loading class so any\n     * loading animations or other effects can be disabled.\n     */\n    image.addEventListener('load', event => {\n      removeLoadingClass(event.target, loadingClass);\n      callback(event);\n    });\n\n    /*\n     * Set up a listener for the custom event that triggers the image load\n     * handler (which loads the image).\n     */\n    image.addEventListener('lazyload-init', loadImage);\n\n    /*\n     * Check if the image is already in the viewport. If so, load it.\n     */\n    maybeTriggerImageLoad(image, lazyLoadEvent);\n  });\n\n  /*\n   * Add an event listener when the page is scrolled. To avoid bogging down the\n   * page, we throttle this call to only run every 100ms.\n   */\n  const scrollHandler = throttle(() => {\n    images.forEach(image => {\n      maybeTriggerImageLoad(image, lazyLoadEvent);\n    });\n  }, 100);\n  window.addEventListener('scroll', scrollHandler);\n}\n\n/**\n * The public function to initialize lazyloading\n * @param  {Object} config configuration options (see `initialize()`)\n * @return {Boolean}       `true` if initialized; `false` if not\n */\nexport function lazyLoadImages(config = {}) {\n\n  // Before we do anything, check if the browser supports `srcset`\n  if ('srcset' in document.createElement('img')) {\n\n    // If we have `srcset` support, initialize the lazyloader.\n    initialize(config);\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./source/scripts/responsive-lazyload.js\n **/"],"sourceRoot":""}